{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fc345d97-487c-4a19-b3a9-608e1fe80e9a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import json\n",
    "import torch\n",
    "import gc\n",
    "import numpy as np\n",
    "from torch_geometric.data import Data\n",
    "from transformers import BertTokenizer, BertModel\n",
    "from collections import defaultdict\n",
    "\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "print(f\"LOG: Using device: {device}\")\n",
    "\n",
    "DATA_DIR = \"./data\"\n",
    "\n",
    "try:\n",
    "    model_name = \".\"\n",
    "    tokenizer = BertTokenizer.from_pretrained(model_name)\n",
    "    model = BertModel.from_pretrained(model_name).to(device)\n",
    "    print(f\"LOG: BERT Model ('{model_name}') and Tokenizer loaded successfully!\")\n",
    "except Exception as e:\n",
    "    print(f\"ERROR: Failed to load BERT model ('{model_name}'). {e}\")\n",
    "    exit(1)\n",
    "\n",
    "def get_embedding(text):\n",
    "    if isinstance(text, list):\n",
    "        text = \" \".join(map(str, text))\n",
    "        \n",
    "    if not text or text.strip().lower() == \"none\":\n",
    "        return torch.zeros(768, device=device)\n",
    "\n",
    "    try:\n",
    "        tokens = tokenizer(text, padding=True, truncation=True, return_tensors=\"pt\").to(device)\n",
    "        with torch.no_grad():\n",
    "            outputs = model(**tokens)\n",
    "        return outputs.last_hidden_state[:, 0, :].squeeze().to(device)\n",
    "    except Exception as e:\n",
    "        print(f\"ERROR: Failed to generate embedding for text: {text[:50]}... {e}\")\n",
    "        return torch.zeros(768, device=device)\n",
    "        \n",
    "input_file = os.path.join(DATA_DIR, \"./input_data/YOUR_FILE_NAME_HERE.json\")\n",
    "\n",
    "if not os.path.exists(input_file):\n",
    "    print(f\"ERROR: Dataset file not found at {input_file}\")\n",
    "    exit(1)\n",
    "\n",
    "with open(input_file, \"r\", encoding=\"utf-8\") as f:\n",
    "    dataset = json.load(f)\n",
    "print(f\"LOG: Loaded {len(dataset)} records from dataset\")\n",
    "\n",
    "output_dir = \"./data/input_data/input_temp_json\"\n",
    "os.makedirs(output_dir, exist_ok=True)\n",
    "\n",
    "model_node = []\n",
    "model_index = []\n",
    "model_features = {}\n",
    "model_features_with_nodes = {}\n",
    "target_node = []\n",
    "target_index = []\n",
    "edge_index = []\n",
    "total_edge_index = []\n",
    "edge_attr = []\n",
    "target_features = {}\n",
    "edge_weight_with_nodes = {}\n",
    "target_edges = []\n",
    "target_edges_with_weights = {}\n",
    "model_dict = {}\n",
    "reverse_model_dict = {}\n",
    "target_dict = {}\n",
    "reverse_target_dict = {}\n",
    "edges_dict = {}\n",
    "count_model = {}\n",
    "count_target = {}\n",
    "target_edge_dict = {}\n",
    "\n",
    "input_edge_index = []\n",
    "input_edge_attr = []\n",
    "input_target_edge_index = []\n",
    "input_target_edge_attr = []\n",
    "\n",
    "for index, data in enumerate(dataset):\n",
    "    paper_id = data.get(\"id\", f\"paper_{index}\")\n",
    "    if (index + 1) % 100 == 0:\n",
    "        print(f\"LOG: Processing record {index + 1}/{len(dataset)}\")\n",
    "        print(f\"LOG: Current model_id count: {len(model_dict)}\")\n",
    "        print(f\"LOG: Current target_id count: {len(target_dict)}\")\n",
    "        print(f\"LOG: Current edge count: {len(edges_dict)}\")\n",
    "        print(f\"LOG: Current target_edge count: {len(target_edges)}\")\n",
    "\n",
    "        top_models = sorted(count_model.items(), key=lambda x: x[1], reverse=True)[:5]\n",
    "        print(\"LOG: Top 5 most frequent model_ids:\")\n",
    "        for model_id, count in top_models:\n",
    "            model_main_text = reverse_model_dict.get(model_id, \"Unknown\")\n",
    "            print(f\"  - {model_id} ({model_main_text}): {count} occurrences\")\n",
    "\n",
    "        top_targets = sorted(count_target.items(), key=lambda x: x[1], reverse=True)[:5]\n",
    "        print(\"LOG: Top 5 most frequent target_ids:\")\n",
    "        for target_id, count in top_targets:\n",
    "            target_text = reverse_target_dict.get(target_id, \"Unknown\")\n",
    "            print(f\"  - {target_id} ({target_text}): {count} occurrences\")\n",
    "\n",
    "        torch.cuda.empty_cache()\n",
    "        gc.collect()\n",
    " \n",
    "    model_main_text = data.get(\"model_main\", \"\").strip().replace(\"none\", \"\")\n",
    "    if not model_main_text:\n",
    "        print(f\"WARNING: Skipping entry with empty model_main\")\n",
    "        continue\n",
    "\n",
    "    model_dict_file = os.path.join(DATA_DIR, \"./temp_json/model_dict.json\")\n",
    "    if not os.path.exists(model_dict_file):\n",
    "        print(f\"ERROR: model_dict.json not found at {model_dict_file}\")\n",
    "        exit(1)\n",
    "\n",
    "    with open(model_dict_file, \"r\", encoding=\"utf-8\") as f:\n",
    "        model_dict = json.load(f)\n",
    "\n",
    "    if model_main_text in model_dict:\n",
    "        model_id = model_dict[model_main_text]\n",
    "        count_model[model_id] = count_model.get(model_id, 0) + 1\n",
    "    else:\n",
    "        print(f\"WARNING: model_main_text not found in model_dict -> {model_main_text}\")\n",
    "        continue\n",
    "\n",
    "    model_main_embedding = get_embedding(model_main_text)\n",
    "\n",
    "    def rodrigues_rotation(vector, angle_deg, axis):\n",
    "        device = vector.device\n",
    "        angle_rad = torch.tensor(np.radians(angle_deg), dtype=torch.float32, device=device)\n",
    "    \n",
    "        axis = axis.to(device) / torch.norm(axis.to(device))\n",
    "        identity = torch.eye(vector.shape[0], device=device)\n",
    "        axis_outer = torch.ger(axis, axis).to(device)\n",
    "\n",
    "        cos_theta = torch.cos(angle_rad)\n",
    "        sin_theta = torch.sin(angle_rad)\n",
    "\n",
    "        rotation_matrix = cos_theta * identity + (1 - cos_theta) * axis_outer + sin_theta * torch.diag(axis)\n",
    "        rotated_vector = torch.matmul(rotation_matrix, vector)\n",
    "\n",
    "        return rotated_vector\n",
    "\n",
    "    common_rotation_axis = torch.ones(768)\n",
    "    common_rotation_axis = common_rotation_axis / torch.norm(common_rotation_axis)\n",
    "\n",
    "    model_features_text = \" \".join([\n",
    "        data.get(\"species\", \"\"), data.get(\"age\", \"\"), data.get(\"sex\", \"\"),\n",
    "        data.get(\"biosample_main\", \"\"), data.get(\"biosample_detail\", \"\"),\n",
    "        data.get(\"experiment_type\", \"\"), data.get(\"model_main\", \"\"),\n",
    "        data.get(\"model_detail1\", \"\"), data.get(\"model_detail2\", \"\"),\n",
    "        data.get(\"model_detail3\", \"\"), data.get(\"timepoint\", \"\")\n",
    "    ]).strip().replace(\"none\", \"\")\n",
    "\n",
    "    model_features_embedding = get_embedding(model_features_text)\n",
    "\n",
    "    species = data.get(\"species\", \"\").strip().lower()\n",
    "    species_rotation_params = {\n",
    "        \"human\": (174.20, 2.5152),\n",
    "        \"mouse\": (176.36, 5.7104),\n",
    "        \"rat\": (173.81, 5.7201)\n",
    "    }\n",
    "\n",
    "    if species in species_rotation_params:\n",
    "        angle, norm_factor = species_rotation_params[species]\n",
    "        rotation_axis = common_rotation_axis.to(model_features_embedding.device)\n",
    "    \n",
    "        model_features_embedding = rodrigues_rotation(model_features_embedding, angle, rotation_axis)\n",
    "        model_features_embedding = model_features_embedding * norm_factor\n",
    "\n",
    "    model_node.append(model_main_embedding)\n",
    "    model_index.append(model_id)\n",
    "    \n",
    "    if model_id not in model_features:\n",
    "        model_features[model_id] = []\n",
    "\n",
    "    model_features[model_id].append(model_features_embedding)\n",
    "   \n",
    "    if model_id not in model_features_with_nodes:\n",
    "        model_features_with_nodes[model_id] = {\"model\": model_main_embedding, \"features\": []}\n",
    "\n",
    "    model_features_with_nodes[model_id][\"features\"].append(model_features_embedding)\n",
    "\n",
    "    targets = data.get(\"targets\", [])\n",
    "\n",
    "    if isinstance(targets, dict):\n",
    "        print(f\"WARNING: `targets` is a dictionary! Converting to list: {targets}\")\n",
    "        targets = [targets]\n",
    "\n",
    "    if not isinstance(targets, list):\n",
    "        print(f\"ERROR: Unexpected format for `targets`: {targets}\")\n",
    "        targets = []\n",
    "\n",
    "    target_ids = []\n",
    "\n",
    "    edge_index = []\n",
    "    edge_attr = [] \n",
    "    \n",
    "    for target in targets:\n",
    "        target_text = target.get(\"target\", \"\").strip().replace(\"none\", \"\")\n",
    "\n",
    "        if not target_text:\n",
    "            print(f\"WARNING: Skipping target with empty name -> {target}\")\n",
    "            continue\n",
    "\n",
    "        target_dict_file = os.path.join(DATA_DIR, \"./temp_json/target_dict.json\")\n",
    "        if not os.path.exists(target_dict_file):\n",
    "            print(f\"ERROR: reverse_target_dict.json not found at {target_dict_file}\")\n",
    "            exit(1)\n",
    "\n",
    "        with open(target_dict_file, \"r\", encoding=\"utf-8\") as f:\n",
    "            target_dict = json.load(f)\n",
    "\n",
    "        if target_text in target_dict:\n",
    "            target_id = target_dict[target_text]\n",
    "            count_target[target_id] = count_target.get(target_id, 0) + 1\n",
    "        else:\n",
    "            print(f\"WARNING: target_text not found in target_dict -> {target_text}\")\n",
    "            continue\n",
    "\n",
    "        target_ids.append(target_id)\n",
    "        target_embedding = get_embedding(target_text)\n",
    "\n",
    "        if isinstance(target, dict):\n",
    "            target = [target]\n",
    "    \n",
    "        if isinstance(target, list):\n",
    "            target_node.append(target_embedding)\n",
    "        else:\n",
    "            print(f\"WARNING: Unexpected type for target: {type(target)}. Skipping append.\")\n",
    "\n",
    "        edge_weight_text = \" \".join([\n",
    "            target[0].get(\"target\", \"\"), target[0].get(\"molecule_type\", \"\"),\n",
    "            target[0].get(\"analysis_main\", \"\"), target[0].get(\"analysis_detail\", \"\"),\n",
    "            target[0].get(\"relation\", \"\"), target[0].get(\"change\", \"\"),\n",
    "            target[0].get(\"significance\", \"\"), target[0].get(\"control\", \"\")\n",
    "        ]).strip().replace(\"none\", \"\")\n",
    "\n",
    "        relation = target[0].get(\"relation\", \"\").strip().lower()\n",
    "        edge_weight_embedding = get_embedding(edge_weight_text)\n",
    "\n",
    "        if relation == \"increase\":\n",
    "            edge_weight_embedding = rodrigues_rotation(edge_weight_embedding, 90, common_rotation_axis)\n",
    "        elif relation == \"decrease\":\n",
    "            edge_weight_embedding = rodrigues_rotation(edge_weight_embedding, -90, common_rotation_axis)\n",
    "\n",
    "        if target_id not in target_features:\n",
    "            target_features[target_id] = []\n",
    "\n",
    "        target_features[target_id].append(edge_weight_embedding)\n",
    "\n",
    "        if target_id not in edge_weight_with_nodes:\n",
    "            edge_weight_with_nodes[target_id] = {\"target\": target_embedding, \"edge_weight\": []} \n",
    "\n",
    "        edge_weight_with_nodes[target_id][\"edge_weight\"].append(edge_weight_embedding)\n",
    "\n",
    "        if (model_id, target_id) not in edges_dict:\n",
    "            edges_dict[(model_id, target_id)] = []\n",
    "\n",
    "        edge_feature = torch.cat((model_features_embedding, edge_weight_embedding), dim=0)  # `model_features_embedding` + `edge_weight_embedding`\n",
    "\n",
    "        new_edge_entry = {\n",
    "            \"model_features\": model_features_embedding,\n",
    "            \"edge_weight\": edge_weight_embedding\n",
    "        }\n",
    "        edges_dict[(model_id, target_id)].append(new_edge_entry)\n",
    "\n",
    "        edge_index.append([model_id, target_id])\n",
    "        total_edge_index.append([model_id, target_id])\n",
    "        edge_attr.append(edge_feature)\n",
    "\n",
    "    target_edge_index = []\n",
    "    target_edge_attr = []\n",
    "    target_edges_with_weights = {}\n",
    "\n",
    "    for i in range(len(target_ids)):\n",
    "        for j in range(i + 1, len(target_ids)):\n",
    "            target_id_i, target_id_j = target_ids[i], target_ids[j]\n",
    "\n",
    "            if (target_id_i, target_id_j) in target_edges_with_weights or (target_id_j, target_id_i) in target_edges_with_weights:\n",
    "                continue\n",
    "\n",
    "            edge_info_i = edges_dict.get((model_id, target_id_i), [])\n",
    "            edge_info_j = edges_dict.get((model_id, target_id_j), [])\n",
    "\n",
    "            if isinstance(edge_info_i, list) and len(edge_info_i) > 0:\n",
    "                edge_info_i = edge_info_i[-1]\n",
    "\n",
    "            if isinstance(edge_info_j, list) and len(edge_info_j) > 0:\n",
    "                edge_info_j = edge_info_j[-1]\n",
    "\n",
    "            if isinstance(edge_info_i, dict) and isinstance(edge_info_j, dict):\n",
    "                edge_weights_i = edge_info_i[\"edge_weight\"]\n",
    "                edge_weights_j = edge_info_j[\"edge_weight\"]\n",
    "            else:\n",
    "                print(f\"WARNING: Skipping edge between {target_id_i} and {target_id_j} due to missing edge_weight.\")\n",
    "                continue\n",
    "\n",
    "            target_edges.append((target_id_i, target_id_j))\n",
    "            target_edges.append((target_id_j, target_id_i))\n",
    "\n",
    "            if (target_id_i, target_id_j) not in target_edges_with_weights:\n",
    "                target_edges_with_weights[(target_id_i, target_id_j)] = []\n",
    "            if (target_id_j, target_id_i) not in target_edges_with_weights:\n",
    "                target_edges_with_weights[(target_id_j, target_id_i)] = []\n",
    "\n",
    "            target_edges_with_weights[(target_id_i, target_id_j)].append({\n",
    "                \"edge_weight_source\": edge_weights_i,\n",
    "                \"edge_weight_target\": edge_weights_j\n",
    "            })\n",
    "            target_edges_with_weights[(target_id_j, target_id_i)].append({\n",
    "                \"edge_weight_source\": edge_weights_j,\n",
    "                \"edge_weight_target\": edge_weights_i\n",
    "            })\n",
    "\n",
    "            if (target_id_i, target_id_j) not in target_edge_dict:\n",
    "                target_edge_dict[(target_id_i, target_id_j)] = []\n",
    "            if (target_id_j, target_id_i) not in target_edge_dict:\n",
    "                target_edge_dict[(target_id_j, target_id_i)] = []\n",
    "\n",
    "            target_edge_dict[(target_id_i, target_id_j)].append([edge_weights_i, edge_weights_j])\n",
    "            target_edge_dict[(target_id_j, target_id_i)].append([edge_weights_j, edge_weights_i])\n",
    "\n",
    "    for (target_id_i, target_id_j), weight_list in target_edges_with_weights.items():\n",
    "            for weight in weight_list:\n",
    "                target_edge_index.append([target_id_i, target_id_j])\n",
    "                target_edge_attr.append(torch.cat((weight[\"edge_weight_source\"], weight[\"edge_weight_target\"]), dim=0))\n",
    "\n",
    "    input_edge_index.extend(edge_index)\n",
    "    input_edge_attr.extend(edge_attr)\n",
    "    input_target_edge_index.extend(target_edge_index)\n",
    "    input_target_edge_attr.extend(target_edge_attr)\n",
    "\n",
    "    print(f\"LOG: Saved processed record {index + 1}/{len(dataset)}\")\n",
    "\n",
    "json_files = {\n",
    "    \"input_edge_index\": os.path.join(output_dir, \"input_edge_index.json\"),\n",
    "    \"input_edge_attr\": os.path.join(output_dir, \"input_edge_attr.json\"),\n",
    "    \"input_target_edge_index\": os.path.join(output_dir, \"input_target_edge_index.json\"),\n",
    "    \"input_target_edge_attr\": os.path.join(output_dir, \"input_target_edge_attr.json\"),\n",
    "}\n",
    "\n",
    "with open(json_files[\"input_edge_index\"], \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(input_edge_index, f, indent=4)\n",
    "with open(json_files[\"input_edge_attr\"], \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump([t.tolist() for t in input_edge_attr], f, indent=4)\n",
    "with open(json_files[\"input_target_edge_index\"], \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(input_target_edge_index, f, indent=4)\n",
    "with open(json_files[\"input_target_edge_attr\"], \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump([t.tolist() for t in input_target_edge_attr], f, indent=4)\n",
    "\n",
    "model_features_with_nodes_file = os.path.join(output_dir, \"input_model_features_with_nodes.json\")\n",
    "edge_weight_with_nodes_file = os.path.join(output_dir, \"input_edge_weight_with_nodes.json\")\n",
    "\n",
    "with open(model_features_with_nodes_file, \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(\n",
    "        {str(k): {\n",
    "            \"model\": v[\"model\"].tolist() if isinstance(v[\"model\"], torch.Tensor) else v[\"model\"], \n",
    "            \"features\": [f.tolist() if isinstance(f, torch.Tensor) else f for f in v[\"features\"]]\n",
    "        }\n",
    "        for k, v in model_features_with_nodes.items()},\n",
    "        f, indent=4\n",
    "    )\n",
    "\n",
    "with open(edge_weight_with_nodes_file, \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(\n",
    "        {str(k): {  \n",
    "            \"target\": v[\"target\"].tolist() if isinstance(v[\"target\"], torch.Tensor) else v[\"target\"], \n",
    "            \"edge_weight\": [ew.tolist() if isinstance(ew, torch.Tensor) else ew for ew in v[\"edge_weight\"]]\n",
    "        }\n",
    "        for k, v in edge_weight_with_nodes.items()},\n",
    "        f, indent=4\n",
    "    )\n",
    "\n",
    "model_features_file = os.path.join(output_dir, \"input_model_features.json\")\n",
    "target_features_file = os.path.join(output_dir, \"input_target_features.json\")\n",
    "\n",
    "with open(model_features_file, \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(\n",
    "        {key: [tensor.tolist() for tensor in value]\n",
    "         for key, value in model_features.items()}, \n",
    "        f, ensure_ascii=False, indent=4\n",
    "    )\n",
    "\n",
    "with open(target_features_file, \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(\n",
    "        {key: [tensor.tolist() for tensor in value]\n",
    "         for key, value in target_features.items()}, \n",
    "        f, ensure_ascii=False, indent=4\n",
    "    )\n",
    "\n",
    "target_edge_dict_file = os.path.join(output_dir, \"input_target_edge_dict.json\")\n",
    "\n",
    "target_edge_dict_serializable = {\n",
    "    str(key): [[tensor_i.tolist(), tensor_j.tolist()] for tensor_i, tensor_j in value]\n",
    "    for key, value in target_edge_dict.items()\n",
    "}\n",
    "\n",
    "with open(target_edge_dict_file, \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(target_edge_dict_serializable, f, ensure_ascii=False, indent=4)\n",
    "\n",
    "model_dict_file = os.path.join(output_dir, \"input_model_dict.json\")\n",
    "target_dict_file = os.path.join(output_dir, \"input_target_dict.json\")\n",
    "\n",
    "with open(model_dict_file, \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(model_dict, f, ensure_ascii=False, indent=4)\n",
    "\n",
    "with open(target_dict_file, \"w\", encoding=\"utf-8\") as f:\n",
    "    json.dump(target_dict, f, ensure_ascii=False, indent=4)\n",
    "\n",
    "print(\"LOG: Data processing completed.\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
