{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c14ed676-e951-4ca3-87bb-01c6843ad86c",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import json\n",
    "import torch\n",
    "import ijson\n",
    "import gc\n",
    "\n",
    "DATA_DIR = \"./data/temp_json\"  # ./data/input_data/input_temp_json for input data\n",
    "OUTPUT_DIR = \"./data/pt_data\"  # ./data/input_data/input_pt_data for input data\n",
    "os.makedirs(OUTPUT_DIR, exist_ok=True)\n",
    "\n",
    "edge_index_file = os.path.join(DATA_DIR, \"edge_index.json\")\n",
    "edge_attr_file = os.path.join(DATA_DIR, \"edge_attr.json\")\n",
    "model_features_with_nodes_file = os.path.join(DATA_DIR, \"model_features_with_nodes.json\")\n",
    "target_edge_index_file = os.path.join(DATA_DIR, \"target_edge_index.json\")\n",
    "target_edge_attr_file = os.path.join(DATA_DIR, \"target_edge_attr.json\")\n",
    "edge_weight_with_nodes_file = os.path.join(DATA_DIR, \"edge_weight_with_nodes.json\")\n",
    "model_features_file = os.path.join(DATA_DIR, \"model_features.json\")\n",
    "target_features_file = os.path.join(DATA_DIR, \"target_features.json\")\n",
    "target_edge_dict_file = os.path.join(DATA_DIR, \"target_edge_dict.json\")\n",
    "\n",
    "edge_index_pt = os.path.join(OUTPUT_DIR, \"edge_index.pt\")\n",
    "edge_attr_pt = os.path.join(OUTPUT_DIR, \"edge_attr.pt\")\n",
    "model_features_with_nodes_pt = os.path.join(OUTPUT_DIR, \"model_features_with_nodes.pt\")\n",
    "target_edge_index_pt = os.path.join(OUTPUT_DIR, \"target_edge_index.pt\")\n",
    "target_edge_attr_pt = os.path.join(OUTPUT_DIR, \"target_edge_attr.pt\")\n",
    "edge_weight_with_nodes_pt = os.path.join(OUTPUT_DIR, \"edge_weight_with_nodes.pt\")\n",
    "model_features_pt = os.path.join(OUTPUT_DIR, \"model_features.pt\")\n",
    "target_features_pt = os.path.join(OUTPUT_DIR, \"target_features.pt\")\n",
    "target_edge_dict_pt = os.path.join(OUTPUT_DIR, \"target_edge_dict.pt\")\n",
    "\n",
    "target_edge_attr_parts_dir = os.path.join(OUTPUT_DIR, \"target_edge_attr_parts\")\n",
    "os.makedirs(target_edge_attr_parts_dir, exist_ok=True)\n",
    "\n",
    "target_edge_dict_parts_dir = os.path.join(OUTPUT_DIR, \"target_edge_dict_parts\")\n",
    "os.makedirs(target_edge_dict_parts_dir, exist_ok=True)\n",
    "\n",
    "def load_json(file_path):\n",
    "    if os.path.exists(file_path):\n",
    "        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n",
    "            return json.load(f)\n",
    "    return None\n",
    "\n",
    "edge_index = load_json(edge_index_file)\n",
    "if edge_index:\n",
    "    edge_index_tensor = torch.tensor(edge_index, dtype=torch.long).T\n",
    "    torch.save(edge_index_tensor, edge_index_pt)\n",
    "    print(f\"Saved: {edge_index_pt}\")\n",
    "\n",
    "edge_attr = load_json(edge_attr_file)\n",
    "if edge_attr:\n",
    "    edge_attr_tensor = torch.tensor(edge_attr, dtype=torch.float32)\n",
    "    torch.save(edge_attr_tensor, edge_attr_pt)\n",
    "    print(f\"Saved: {edge_attr_pt}\")\n",
    "\n",
    "model_features_with_nodes = load_json(model_features_with_nodes_file)\n",
    "\n",
    "if model_features_with_nodes:    \n",
    "    feature_counts = {\n",
    "        int(model_id): len(v[\"features\"]) for model_id, v in model_features_with_nodes.items()\n",
    "    }\n",
    "\n",
    "    top_10_models = sorted(feature_counts.items(), key=lambda x: x[1], reverse=True)[:10]\n",
    "\n",
    "    for model_id, num_features in top_10_models:\n",
    "        print(f\"  - Model ID: {model_id} | Features: {num_features}\")\n",
    "\n",
    "    converted_feature_data = {}\n",
    "    for model_id, v in model_features_with_nodes.items():\n",
    "        model_id = int(model_id)\n",
    "\n",
    "        model_tensor = torch.tensor(v[\"model\"], dtype=torch.float32) if \"model\" in v else torch.zeros(768)\n",
    "\n",
    "        feature_tensors = [torch.tensor(f, dtype=torch.float32) for f in v[\"features\"]]\n",
    "        num_features = len(feature_tensors)\n",
    "\n",
    "        if num_features > 0:\n",
    "            avg_feature_tensor = torch.stack(feature_tensors).mean(dim=0)\n",
    "        else:\n",
    "            avg_feature_tensor = torch.zeros(768)\n",
    "\n",
    "        converted_feature_data[model_id] = {\n",
    "            \"model\": model_tensor,\n",
    "            \"features\": avg_feature_tensor\n",
    "        }\n",
    "\n",
    "    torch.save(converted_feature_data, model_features_with_nodes_pt)\n",
    "    print(f\"\\nSaved: {model_features_with_nodes_pt}\")\n",
    "else:\n",
    "    print(\"No data found in model_features_with_nodes.json\")\n",
    "\n",
    "target_edge_index = load_json(target_edge_index_file)\n",
    "if target_edge_index:\n",
    "    target_edge_index_tensor = torch.tensor(target_edge_index, dtype=torch.long).T\n",
    "    torch.save(target_edge_index_tensor, target_edge_index_pt)\n",
    "    print(f\"Saved: {target_edge_index_pt}\")\n",
    "\n",
    "if os.path.exists(target_edge_attr_file):\n",
    "    batch_size = 100_000\n",
    "    part_id = 0\n",
    "    attr_list = []\n",
    "    with open(target_edge_attr_file, \"r\", encoding=\"utf-8\") as f:\n",
    "        for i, vec in enumerate(ijson.items(f, \"item\")):\n",
    "            attr_list.append(torch.tensor(vec, dtype=torch.float32))\n",
    "            if (i + 1) % batch_size == 0:\n",
    "                path = os.path.join(target_edge_attr_parts_dir, f\"part_{part_id}.pt\")\n",
    "                torch.save(torch.stack(attr_list), path)\n",
    "                print(f\"Saved: {path} ({i+1} entries)\")\n",
    "                attr_list.clear()\n",
    "                gc.collect()\n",
    "                part_id += 1\n",
    "        if attr_list:\n",
    "            path = os.path.join(target_edge_attr_parts_dir, f\"part_{part_id}.pt\")\n",
    "            torch.save(torch.stack(attr_list), path)\n",
    "            print(f\"Saved final: {path}\")\n",
    "            attr_list.clear()\n",
    "            gc.collect()\n",
    "    all_parts = [torch.load(os.path.join(target_edge_attr_parts_dir, f))\n",
    "                 for f in sorted(os.listdir(target_edge_attr_parts_dir)) if f.endswith(\".pt\")]\n",
    "    merged_tensor = torch.cat(all_parts, dim=0)\n",
    "    torch.save(merged_tensor, target_edge_attr_pt)\n",
    "    print(f\"Merged and saved: {target_edge_attr_pt}\")\n",
    "else:\n",
    "    print(\"target_edge_attr.json not found.\")\n",
    "\n",
    "edge_weight_with_nodes = load_json(edge_weight_with_nodes_file)\n",
    "\n",
    "if edge_weight_with_nodes:    \n",
    "    edge_weight_counts = {\n",
    "        int(target_id): len(v[\"edge_weight\"]) for target_id, v in edge_weight_with_nodes.items()\n",
    "    }\n",
    "\n",
    "    top_10_edges = sorted(edge_weight_counts.items(), key=lambda x: x[1], reverse=True)[:10]\n",
    "\n",
    "    for target_id, num_edge_weight in top_10_edges:\n",
    "        print(f\"  - Target ID: {target_id} | Edge weight: {num_edge_weight}\")\n",
    "\n",
    "    converted_edge_weight_data = {}\n",
    "    for target_id, v in edge_weight_with_nodes.items():\n",
    "        target_id = int(target_id)\n",
    "\n",
    "        target_tensor = torch.tensor(v[\"target\"], dtype=torch.float32) if \"target\" in v else torch.zeros(768)\n",
    "\n",
    "        edge_weight_tensors = [torch.tensor(f, dtype=torch.float32) for f in v[\"edge_weight\"]]\n",
    "        num_edge_weight = len(edge_weight_tensors)\n",
    "\n",
    "        if num_edge_weight > 0:\n",
    "            avg_edge_weight_tensor = torch.stack(edge_weight_tensors).mean(dim=0)\n",
    "        else:\n",
    "            avg_edge_weight_tensor = torch.zeros(768)\n",
    "\n",
    "        converted_edge_weight_data[target_id] = {\n",
    "            \"target\": target_tensor,\n",
    "            \"edge_weight\": avg_edge_weight_tensor\n",
    "        }\n",
    "\n",
    "    torch.save(converted_edge_weight_data, edge_weight_with_nodes_pt)\n",
    "    print(f\"\\nSaved: {edge_weight_with_nodes_pt}\")\n",
    "else:\n",
    "    print(\"No data found in edge_weight_with_nodes.json\")\n",
    "\n",
    "model_features = load_json(model_features_file)\n",
    "if model_features:\n",
    "    converted_model_features = {\n",
    "        int(model_id): torch.mean(torch.stack([torch.tensor(f, dtype=torch.float32) for f in v]), dim=0) \n",
    "        for model_id, v in model_features.items()\n",
    "    }\n",
    "    torch.save(converted_model_features, model_features_pt)\n",
    "    print(f\"Saved: {model_features_pt}\")\n",
    "else:\n",
    "    print(\"No data found in model_features.json\")\n",
    "\n",
    "target_features = load_json(target_features_file)\n",
    "if target_features:\n",
    "    converted_target_features = {\n",
    "        int(target_id): torch.mean(torch.stack([torch.tensor(f, dtype=torch.float32) for f in v]), dim=0) \n",
    "        for target_id, v in target_features.items()\n",
    "    }\n",
    "    torch.save(converted_target_features, target_features_pt)\n",
    "    print(f\"Saved: {target_features_pt}\")\n",
    "else:\n",
    "    print(\"No data found in target_features.json\")\n",
    "\n",
    "if os.path.exists(target_edge_dict_file):\n",
    "    print(\"\\nConverting target_edge_dict.json in streaming mode...\")\n",
    "    batch_size = 5000\n",
    "    part_id = 0\n",
    "    count = 0\n",
    "    converted_dict = {}\n",
    "\n",
    "    with open(target_edge_dict_file, \"r\", encoding=\"utf-8\") as f:\n",
    "        for key, value in ijson.kvitems(f, \"\"):\n",
    "            key_tuple = eval(key)\n",
    "            tensor_pairs = [(torch.tensor(i, dtype=torch.float32), torch.tensor(j, dtype=torch.float32))\n",
    "                            for i, j in value]\n",
    "            src_avg = torch.stack([t[0] for t in tensor_pairs]).mean(dim=0)\n",
    "            tgt_avg = torch.stack([t[1] for t in tensor_pairs]).mean(dim=0)\n",
    "            converted_dict[key_tuple] = (src_avg, tgt_avg)\n",
    "            count += 1\n",
    "\n",
    "            if count % batch_size == 0:\n",
    "                path = os.path.join(target_edge_dict_parts_dir, f\"part_{part_id}.pt\")\n",
    "                torch.save(converted_dict, path)\n",
    "                print(f\"Saved: {path} ({count} entries)\")\n",
    "                converted_dict.clear()\n",
    "                gc.collect()\n",
    "                part_id += 1\n",
    "\n",
    "        if converted_dict:\n",
    "            path = os.path.join(target_edge_dict_parts_dir, f\"part_{part_id}.pt\")\n",
    "            torch.save(converted_dict, path)\n",
    "            print(f\"Saved final: {path}\")\n",
    "            converted_dict.clear()\n",
    "            gc.collect()\n",
    "\n",
    "    merged = {}\n",
    "    for f in sorted(os.listdir(target_edge_dict_parts_dir)):\n",
    "        if f.endswith(\".pt\"):\n",
    "            part = torch.load(os.path.join(target_edge_dict_parts_dir, f))\n",
    "            merged.update(part)\n",
    "    torch.save(merged, target_edge_dict_pt)\n",
    "    print(f\"Merged and saved: {target_edge_dict_pt}\")\n",
    "else:\n",
    "    print(\"target_edge_dict.json not found.\")\n",
    "\n",
    "print(\"All JSON files converted to .pt format successfully.\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
